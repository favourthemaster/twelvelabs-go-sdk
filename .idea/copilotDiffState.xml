<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README_ORGANIZED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README_ORGANIZED.md" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="# TwelveLabs Go SDK&#10;&#10;A Go client for the [TwelveLabs API](https://docs.twelvelabs.io/), enabling developers to interact with video understanding and search capabilities from Go applications.&#10;&#10;## Features&#10;- Video upload and management&#10;- Video search (semantic, object, action, speech, text, etc.)&#10;- Embeddings generation&#10;- Index management&#10;- Task management&#10;- Idiomatic Go types and error handling&#10;&#10;## Installation&#10;&#10;```&#10;go get github.com/favourthemaster/twelvelabs-go-sdk&#10;```&#10;&#10;## Usage&#10;&#10;### 1. Import the SDK&#10;&#10;```go&#10;import (&#10;    &quot;github.com/favourthemaster/twelvelabs-go-sdk&quot;&#10;    &quot;os&quot;&#10;)&#10;```&#10;&#10;### 2. Initialize the Client&#10;&#10;```go&#10;client, err := twelvelabs.NewTwelveLabs(&amp;twelvelabs.Options{&#10;    APIKey: os.Getenv(&quot;TWELVE_LABS_API_KEY&quot;), // or leave blank to use env var&#10;})&#10;if err != nil {&#10;    // handle error&#10;}&#10;```&#10;&#10;&gt; **Note:** If you do not provide an API key, the SDK will use the `TWELVE_LABS_API_KEY` environment variable. You can also set a custom base URL with the `BaseURL` field in `Options`.&#10;&#10;### 3. Search Example&#10;&#10;```go&#10;import (&#10;    &quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;)&#10;&#10;req := models.SearchRequest{&#10;    Query: &quot;A woman vlogs about her summer day&quot;,&#10;    IndexID: &quot;your_index_id&quot;,&#10;}&#10;resp, err := client.Search.Search(req)&#10;if err != nil {&#10;    // handle error&#10;}&#10;for _, result := range resp.Data {&#10;    fmt.Println(result.Transcription)&#10;}&#10;```&#10;&#10;### 4. Video Upload Example&#10;&#10;```go&#10;videoID, err := client.ManageVideos.Upload(&quot;/path/to/video.mp4&quot;)&#10;if err != nil {&#10;    // handle error&#10;}&#10;fmt.Println(&quot;Uploaded video ID:&quot;, videoID)&#10;```&#10;&#10;### 5. Embeddings Example&#10;&#10;```go&#10;embedding, err := client.Embed.GetEmbedding(&quot;your_text_or_video_id&quot;)&#10;if err != nil {&#10;    // handle error&#10;}&#10;fmt.Println(embedding)&#10;```&#10;&#10;## Examples&#10;See the [`examples/`](./examples/) directory for more usage patterns:&#10;- `basic_usage.go`: Basic search and video upload&#10;- `search_example.go`: Advanced search queries&#10;- `embeddings_example.go`: Embedding generation&#10;- `tasks_example.go`: Task management&#10;- `videos_example.go`: Video management&#10;&#10;## Error Handling&#10;All errors are wrapped in the `pkg/errors` package for consistent error handling.&#10;&#10;## Types&#10;All request and response types are defined in `pkg/models/types.go`.&#10;&#10;## Contributing&#10;Pull requests are welcome! Please open issues for bugs or feature requests.&#10;&#10;## License&#10;MIT" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/errors/errors.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/errors/errors.go" />
              <option name="originalContent" value="package errors&#10;&#10;import &quot;fmt&quot;&#10;&#10;// APIError represents a generic API error&#10;type APIError struct {&#10;&#9;StatusCode int    `json:&quot;status_code&quot;`&#10;&#9;Message    string `json:&quot;message&quot;`&#10;}&#10;&#10;func (e *APIError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;API Error %d: %s&quot;, e.StatusCode, e.Message)&#10;}&#10;&#10;// BadRequestError represents a 400 Bad Request error&#10;type BadRequestError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *BadRequestError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Bad Request (400): %s&quot;, e.Message)&#10;}&#10;&#10;// UnauthorizedError represents a 401 Unauthorized error&#10;type UnauthorizedError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *UnauthorizedError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Unauthorized (401): %s&quot;, e.Message)&#10;}&#10;&#10;// NotFoundError represents a 404 Not Found error&#10;type NotFoundError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *NotFoundError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Not Found (404): %s&quot;, e.Message)&#10;}&#10;&#10;// TooManyRequestsError represents a 429 Too Many Requests error&#10;type TooManyRequestsError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *TooManyRequestsError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Too Many Requests (429): %s&quot;, e.Message)&#10;}&#10;&#10;// InternalServerError represents a 500 Internal Server Error&#10;type InternalServerError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *InternalServerError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Internal Server Error (500): %s&quot;, e.Message)&#10;}&#10;" />
              <option name="updatedContent" value="package errors&#10;&#10;import &quot;fmt&quot;&#10;&#10;// APIError represents a generic API error&#10;type APIError struct {&#10;&#9;StatusCode int    `json:&quot;status_code&quot;`&#10;&#9;Message    string `json:&quot;message&quot;`&#10;}&#10;&#10;func (e *APIError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;API Error %d: %s&quot;, e.StatusCode, e.Message)&#10;}&#10;&#10;// BadRequestError represents a 400 Bad Request error&#10;type BadRequestError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *BadRequestError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Bad Request (400): %s&quot;, e.Message)&#10;}&#10;&#10;// UnauthorizedError represents a 401 Unauthorized error&#10;type UnauthorizedError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *UnauthorizedError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Unauthorized (401): %s&quot;, e.Message)&#10;}&#10;&#10;// NotFoundError represents a 404 Not Found error&#10;type NotFoundError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *NotFoundError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Not Found (404): %s&quot;, e.Message)&#10;}&#10;&#10;// TooManyRequestsError represents a 429 Too Many Requests error&#10;type TooManyRequestsError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *TooManyRequestsError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Too Many Requests (429): %s&quot;, e.Message)&#10;}&#10;&#10;// InternalServerError represents a 500 Internal Server Error&#10;type InternalServerError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *InternalServerError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Internal Server Error (500): %s&quot;, e.Message)&#10;}&#10;&#10;// ValidationError represents a validation error for invalid parameters&#10;type ValidationError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *ValidationError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Validation Error: %s&quot;, e.Message)&#10;}&#10;&#10;// ServiceError represents a service-level error&#10;type ServiceError struct {&#10;&#9;APIError&#10;&#9;ServiceName string&#10;}&#10;&#10;func (e *ServiceError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;%s Service Error: %s&quot;, e.ServiceName, e.Message)&#10;}&#10;&#10;// RequestError represents an error creating or processing a request&#10;type RequestError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *RequestError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Request Error: %s&quot;, e.Message)&#10;}&#10;&#10;// TimeoutError represents a timeout error&#10;type TimeoutError struct {&#10;&#9;APIError&#10;}&#10;&#10;func (e *TimeoutError) Error() string {&#10;&#9;return fmt.Sprintf(&quot;Timeout Error: %s&quot;, e.Message)&#10;}&#10;&#10;// NewBadRequestError creates a new BadRequestError&#10;func NewBadRequestError(message string) *BadRequestError {&#10;&#9;return &amp;BadRequestError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewUnauthorizedError creates a new UnauthorizedError&#10;func NewUnauthorizedError(message string) *UnauthorizedError {&#10;&#9;return &amp;UnauthorizedError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 401,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewNotFoundError creates a new NotFoundError&#10;func NewNotFoundError(message string) *NotFoundError {&#10;&#9;return &amp;NotFoundError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 404,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewTooManyRequestsError creates a new TooManyRequestsError&#10;func NewTooManyRequestsError(message string) *TooManyRequestsError {&#10;&#9;return &amp;TooManyRequestsError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 429,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewInternalServerError creates a new InternalServerError&#10;func NewInternalServerError(message string) *InternalServerError {&#10;&#9;return &amp;InternalServerError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 500,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewValidationError creates a new ValidationError&#10;func NewValidationError(message string) *ValidationError {&#10;&#9;return &amp;ValidationError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewServiceError creates a new ServiceError&#10;func NewServiceError(serviceName, message string) *ServiceError {&#10;&#9;return &amp;ServiceError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 500,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;&#9;ServiceName: serviceName,&#10;&#9;}&#10;}&#10;&#10;// NewRequestError creates a new RequestError&#10;func NewRequestError(message string) *RequestError {&#10;&#9;return &amp;RequestError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 400,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;// NewTimeoutError creates a new TimeoutError&#10;func NewTimeoutError(message string) *TimeoutError {&#10;&#9;return &amp;TimeoutError{&#10;&#9;&#9;APIError: APIError{&#10;&#9;&#9;&#9;StatusCode: 408,&#10;&#9;&#9;&#9;Message:    message,&#10;&#9;&#9;},&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/wrappers/analyze.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/wrappers/analyze.go" />
              <option name="originalContent" value="// Package wrappers provides high-level wrapper interfaces for TwelveLabs API services.&#10;// These wrappers add convenience methods and enhanced error handling over the base services.&#10;package wrappers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// AnalyzeWrapper provides high-level video analysis capabilities including&#10;// AI-powered content analysis, summarization, gist generation, and streaming responses.&#10;type AnalyzeWrapper struct {&#10;&#9;service *services.AnalyzeService&#10;}&#10;&#10;// NewAnalyzeWrapper creates a new AnalyzeWrapper instance.&#10;func NewAnalyzeWrapper(service *services.AnalyzeService) *AnalyzeWrapper {&#10;&#9;return &amp;AnalyzeWrapper{service: service}&#10;}&#10;&#10;// Analyze performs AI-powered video analysis with a custom prompt.&#10;// This method analyzes video content and returns insights based on your specific question or prompt.&#10;//&#10;// Parameters:&#10;//   - request: AnalyzeRequest containing VideoID, Prompt, and optional parameters like Temperature and Stream&#10;//&#10;// Returns:&#10;//   - AnalyzeResponse containing the analysis results and metadata&#10;//   - error if the analysis fails&#10;//&#10;// Example:&#10;//&#10;//&#9;response, err := client.Analyze.Analyze(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID:     &quot;video_id_here&quot;,&#10;//&#9;    Prompt:      &quot;What objects and people can you see in this video?&quot;,&#10;//&#9;    Temperature: 0.7, // Optional: controls response creativity (0.0-1.0)&#10;//&#9;    Stream:      false, // Set to true for streaming responses&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Println(&quot;Analysis:&quot;, response.Data)&#10;func (aw *AnalyzeWrapper) Analyze(request *models.AnalyzeRequest) (*models.AnalyzeResponse, error) {&#10;&#9;result, err := aw.service.Analyze(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;video analysis failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// AnalyzeStream performs streaming video analysis, calling the provided callback&#10;// function for each chunk of the response as it arrives in real-time.&#10;//&#10;// This is useful for long analysis requests where you want to show progress&#10;// or start processing results before the full analysis is complete.&#10;//&#10;// Parameters:&#10;//   - request: AnalyzeRequest with VideoID and Prompt (Stream field is automatically set to true)&#10;//   - callback: Function called for each streaming event with AnalyzeStreamResponse&#10;//&#10;// Returns:&#10;//   - error if the streaming analysis fails&#10;//&#10;// The callback receives events with different EventType values:&#10;//   - &quot;stream_start&quot;: Analysis has begun&#10;//   - &quot;text_generation&quot;: New text chunk available in the Text field&#10;//   - &quot;stream_end&quot;: Analysis completed, check Metadata for usage info&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Analyze.AnalyzeStream(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID: &quot;video_id_here&quot;,&#10;//&#9;    Prompt:  &quot;Describe what happens in this video step by step&quot;,&#10;//&#9;}, func(event *models.AnalyzeStreamResponse) error {&#10;//&#9;    switch event.EventType {&#10;//&#9;    case &quot;text_generation&quot;:&#10;//&#9;        fmt.Print(event.Text) // Print each chunk as it arrives&#10;//&#9;    case &quot;stream_end&quot;:&#10;//&#9;        fmt.Println(&quot;\nAnalysis completed!&quot;)&#10;//&#9;    }&#10;//&#9;    return nil&#10;//&#9;})&#10;func (aw *AnalyzeWrapper) AnalyzeStream(request *models.AnalyzeRequest, callback func(*models.AnalyzeStreamResponse) error) error {&#10;&#9;err := aw.service.AnalyzeStream(request, callback)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;streaming video analysis failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// GenerateSummary creates various types of video summaries including general summaries,&#10;// chapter breakdowns with timestamps, and highlight reels.&#10;//&#10;// Parameters:&#10;//   - request: GenerateSummaryRequest with VideoID, Type, and optional Prompt&#10;//&#10;// Supported Types:&#10;//   - &quot;summary&quot;: General video summary&#10;//   - &quot;chapter&quot;: Chapter titles with timestamps&#10;//   - &quot;highlight&quot;: Key highlights and moments&#10;//&#10;// Returns:&#10;//   - GenerateSummaryResponse with the generated content in the appropriate field&#10;//   - error if summary generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Generate a general summary&#10;//&#9;summary, err := client.Analyze.GenerateSummary(&amp;models.GenerateSummaryRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Type:    &quot;summary&quot;,&#10;//&#9;    Prompt:  &quot;Provide a brief overview of the video content&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Generate chapters with timestamps&#10;//&#9;chapters, err := client.Analyze.GenerateSummary(&amp;models.GenerateSummaryRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Type:    &quot;chapter&quot;,&#10;//&#9;})&#10;func (aw *AnalyzeWrapper) GenerateSummary(request *models.GenerateSummaryRequest) (*models.GenerateSummaryResponse, error) {&#10;&#9;result, err := aw.service.GenerateSummary(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;video summary generation failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// GenerateGist creates concise video metadata including titles, topics, and hashtags.&#10;// This is useful for content organization, SEO, and social media optimization.&#10;//&#10;// Parameters:&#10;//   - request: GenerateGistRequest with VideoID and Types array&#10;//&#10;// Supported Types:&#10;//   - &quot;title&quot;: Auto-generated video titles&#10;//   - &quot;topic&quot;: Main topics and themes&#10;//   - &quot;hashtag&quot;: Relevant hashtags for social media&#10;//&#10;// Returns:&#10;//   - GenerateGistResponse with the requested gist information&#10;//   - error if gist generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;gist, err := client.Analyze.GenerateGist(&amp;models.GenerateGistRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Types:   []string{&quot;title&quot;, &quot;topic&quot;, &quot;hashtag&quot;},&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Title: %s\n&quot;, gist.Title)&#10;//&#9;fmt.Printf(&quot;Topics: %s\n&quot;, gist.Topics)&#10;//&#9;fmt.Printf(&quot;Hashtags: %v\n&quot;, gist.Hashtags)&#10;func (aw *AnalyzeWrapper) GenerateGist(request *models.GenerateGistRequest) (*models.GenerateGistResponse, error) {&#10;&#9;result, err := aw.service.GenerateGist(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;video gist generation failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;" />
              <option name="updatedContent" value="// Package wrappers provides high-level wrapper interfaces for TwelveLabs API services.&#10;// These wrappers add convenience methods and enhanced error handling over the base services.&#10;package wrappers&#10;&#10;import (&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/errors&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// AnalyzeWrapper provides high-level video analysis capabilities including&#10;// AI-powered content analysis, summarization, gist generation, and streaming responses.&#10;type AnalyzeWrapper struct {&#10;&#9;service *services.AnalyzeService&#10;}&#10;&#10;// NewAnalyzeWrapper creates a new AnalyzeWrapper instance.&#10;func NewAnalyzeWrapper(service *services.AnalyzeService) *AnalyzeWrapper {&#10;&#9;return &amp;AnalyzeWrapper{service: service}&#10;}&#10;&#10;// Analyze performs AI-powered video analysis with a custom prompt.&#10;// This method analyzes video content and returns insights based on your specific question or prompt.&#10;//&#10;// Parameters:&#10;//   - request: AnalyzeRequest containing VideoID, Prompt, and optional parameters like Temperature and Stream&#10;//&#10;// Returns:&#10;//   - AnalyzeResponse containing the analysis results and metadata&#10;//   - error if the analysis fails&#10;//&#10;// Example:&#10;//&#10;//&#9;response, err := client.Analyze.Analyze(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID:     &quot;video_id_here&quot;,&#10;//&#9;    Prompt:      &quot;What objects and people can you see in this video?&quot;,&#10;//&#9;    Temperature: 0.7, // Optional: controls response creativity (0.0-1.0)&#10;//&#9;    Stream:      false, // Set to true for streaming responses&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Println(&quot;Analysis:&quot;, response.Data)&#10;func (aw *AnalyzeWrapper) Analyze(request *models.AnalyzeRequest) (*models.AnalyzeResponse, error) {&#10;&#9;result, err := aw.service.Analyze(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Analyze&quot;, &quot;video analysis failed: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// AnalyzeStream performs streaming video analysis, calling the provided callback&#10;// function for each chunk of the response as it arrives in real-time.&#10;//&#10;// This is useful for long analysis requests where you want to show progress&#10;// or start processing results before the full analysis is complete.&#10;//&#10;// Parameters:&#10;//   - request: AnalyzeRequest with VideoID and Prompt (Stream field is automatically set to true)&#10;//   - callback: Function called for each streaming event with AnalyzeStreamResponse&#10;//&#10;// Returns:&#10;//   - error if the streaming analysis fails&#10;//&#10;// The callback receives events with different EventType values:&#10;//   - &quot;stream_start&quot;: Analysis has begun&#10;//   - &quot;text_generation&quot;: New text chunk available in the Text field&#10;//   - &quot;stream_end&quot;: Analysis completed, check Metadata for usage info&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Analyze.AnalyzeStream(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID: &quot;video_id_here&quot;,&#10;//&#9;    Prompt:  &quot;Describe what happens in this video step by step&quot;,&#10;//&#9;}, func(event *models.AnalyzeStreamResponse) error {&#10;//&#9;    switch event.EventType {&#10;//&#9;    case &quot;text_generation&quot;:&#10;//&#9;        fmt.Print(event.Text) // Print each chunk as it arrives&#10;//&#9;    case &quot;stream_end&quot;:&#10;//&#9;        fmt.Println(&quot;\nAnalysis completed!&quot;)&#10;//&#9;    }&#10;//&#9;    return nil&#10;//&#9;})&#10;func (aw *AnalyzeWrapper) AnalyzeStream(request *models.AnalyzeRequest, callback func(*models.AnalyzeStreamResponse) error) error {&#10;&#9;err := aw.service.AnalyzeStream(request, callback)&#10;&#9;if err != nil {&#10;&#9;&#9;return errors.NewServiceError(&quot;Analyze&quot;, &quot;streaming video analysis failed: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// GenerateSummary creates various types of video summaries including general summaries,&#10;// chapter breakdowns with timestamps, and highlight reels.&#10;//&#10;// Parameters:&#10;//   - request: GenerateSummaryRequest with VideoID, Type, and optional Prompt&#10;//&#10;// Supported Types:&#10;//   - &quot;summary&quot;: General video summary&#10;//   - &quot;chapter&quot;: Chapter titles with timestamps&#10;//   - &quot;highlight&quot;: Key highlights and moments&#10;//&#10;// Returns:&#10;//   - GenerateSummaryResponse with the generated content in the appropriate field&#10;//   - error if summary generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Generate a general summary&#10;//&#9;summary, err := client.Analyze.GenerateSummary(&amp;models.GenerateSummaryRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Type:    &quot;summary&quot;,&#10;//&#9;    Prompt:  &quot;Provide a brief overview of the video content&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Generate chapters with timestamps&#10;//&#9;chapters, err := client.Analyze.GenerateSummary(&amp;models.GenerateSummaryRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Type:    &quot;chapter&quot;,&#10;//&#9;})&#10;func (aw *AnalyzeWrapper) GenerateSummary(request *models.GenerateSummaryRequest) (*models.GenerateSummaryResponse, error) {&#10;&#9;result, err := aw.service.GenerateSummary(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Analyze&quot;, &quot;video summary generation failed: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// GenerateGist creates concise video metadata including titles, topics, and hashtags.&#10;// This is useful for content organization, SEO, and social media optimization.&#10;//&#10;// Parameters:&#10;//   - request: GenerateGistRequest with VideoID and Types array&#10;//&#10;// Supported Types:&#10;//   - &quot;title&quot;: Auto-generated video titles&#10;//   - &quot;topic&quot;: Main topics and themes&#10;//   - &quot;hashtag&quot;: Relevant hashtags for social media&#10;//&#10;// Returns:&#10;//   - GenerateGistResponse with the requested gist information&#10;//   - error if gist generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;gist, err := client.Analyze.GenerateGist(&amp;models.GenerateGistRequest{&#10;//&#9;    VideoID: &quot;video_id&quot;,&#10;//&#9;    Types:   []string{&quot;title&quot;, &quot;topic&quot;, &quot;hashtag&quot;},&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Title: %s\n&quot;, gist.Title)&#10;//&#9;fmt.Printf(&quot;Topics: %s\n&quot;, gist.Topics)&#10;//&#9;fmt.Printf(&quot;Hashtags: %v\n&quot;, gist.Hashtags)&#10;func (aw *AnalyzeWrapper) GenerateGist(request *models.GenerateGistRequest) (*models.GenerateGistResponse, error) {&#10;&#9;result, err := aw.service.GenerateGist(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Analyze&quot;, &quot;video gist generation failed: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/wrappers/embed.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/wrappers/embed.go" />
              <option name="originalContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// EmbedWrapper provides high-level embedding generation capabilities for multiple media types&#10;// including text, images, videos, and audio content using TwelveLabs foundation models.&#10;type EmbedWrapper struct {&#10;&#9;service *services.EmbedService&#10;}&#10;&#10;// NewEmbedWrapper creates a new EmbedWrapper instance.&#10;func NewEmbedWrapper(service *services.EmbedService) *EmbedWrapper {&#10;&#9;return &amp;EmbedWrapper{service: service}&#10;}&#10;&#10;// EmbedWrapperRequest represents a comprehensive embedding request supporting all media types.&#10;// Only specify the fields relevant to your embedding type (e.g., Text for text embeddings).&#10;type EmbedWrapperRequest struct {&#10;&#9;// ModelName specifies the embedding model to use (e.g., &quot;Marengo-retrieval-2.7&quot;)&#10;&#9;ModelName string `json:&quot;model_name&quot;`&#10;&#10;&#9;// Video embedding options (use one of: VideoID, VideoFile, or VideoURL)&#10;&#9;VideoID   string `json:&quot;video_id&quot;`   // Video ID from uploaded content&#10;&#9;VideoFile string `json:&quot;video_file&quot;` // Local video file path&#10;&#9;VideoURL  string `json:&quot;video_url&quot;`  // Publicly accessible video URL&#10;&#10;&#9;// Text embedding option&#10;&#9;Text string `json:&quot;text&quot;` // Text content to embed&#10;&#10;&#9;// Audio embedding options (use one of: AudioFile or AudioURL)&#10;&#9;AudioFile string `json:&quot;audio_file&quot;` // Local audio file path&#10;&#9;AudioURL  string `json:&quot;audio_url&quot;`  // Publicly accessible audio URL&#10;&#10;&#9;// Image embedding options (use one of: ImageFile or ImageURL)&#10;&#9;ImageFile string `json:&quot;image_file&quot;` // Local image file path&#10;&#9;ImageURL  string `json:&quot;image_url&quot;`  // Publicly accessible image URL&#10;}&#10;&#10;// Create generates embeddings for any supported media type based on the request content.&#10;// This unified method automatically detects the embedding type from the provided fields.&#10;//&#10;// Supported Models:&#10;//   - &quot;Marengo-retrieval-2.7&quot;: Latest multimodal embedding model&#10;//   - &quot;Marengo-retrieval-2.6&quot;: Previous generation model&#10;//&#10;// Parameters:&#10;//   - request: EmbedWrapperRequest with ModelName and content (text, video, audio, or image)&#10;//&#10;// Returns:&#10;//   - EmbedResponse containing the generated embedding vector and metadata&#10;//   - error if embedding generation fails&#10;//&#10;// Examples:&#10;//&#10;//&#9;// Text embedding&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    Text:      &quot;A person running through a forest trail&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Video embedding from uploaded content&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    VideoID:   &quot;your_video_id&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Image embedding from URL&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    ImageURL:  &quot;https://example.com/image.jpg&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Audio embedding from local file&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    AudioFile: &quot;./audio/sample.mp3&quot;,&#10;//&#9;})&#10;func (ew *EmbedWrapper) Create(request *EmbedWrapperRequest) (*models.EmbedResponse, error) {&#10;&#9;// Convert to the base service request format&#10;&#9;baseRequest := &amp;models.EmbedRequest{&#10;&#9;&#9;ModelName: request.ModelName,&#10;&#9;&#9;VideoID:   request.VideoID,&#10;&#9;&#9;VideoFile: request.VideoFile,&#10;&#9;&#9;VideoURL:  request.VideoURL,&#10;&#9;&#9;Text:      request.Text,&#10;&#9;&#9;ImageURL:  request.ImageURL,&#10;&#9;&#9;ImageFile: request.ImageFile,&#10;&#9;&#9;AudioURL:  request.AudioURL,&#10;&#9;&#9;AudioFile: request.AudioFile,&#10;&#9;}&#10;&#10;&#9;// Use the existing Create method from the base service&#10;&#9;result, err := ew.service.Create(baseRequest)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;embedding creation failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// CreateVideoEmbedding is a convenience method for video embeddings&#10;func (ew *EmbedWrapper) CreateVideoEmbedding(modelName, videoURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;VideoURL:  videoURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateTextEmbedding is a convenience method for generating text embeddings.&#10;// This method simplifies the most common embedding use case.&#10;//&#10;// Parameters:&#10;//   - modelName: The embedding model to use (e.g., &quot;Marengo-retrieval-2.7&quot;)&#10;//   - text: The text content to embed&#10;//&#10;// Returns:&#10;//   - EmbedResponse containing the text embedding vector&#10;//   - error if embedding generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;embedding, err := client.Embed.CreateTextEmbedding(&#10;//&#9;    &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    &quot;A beautiful sunset over the ocean&quot;,&#10;//&#9;)&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Generated %d-dimensional embedding\n&quot;, len(embedding.Embeddings))&#10;func (ew *EmbedWrapper) CreateTextEmbedding(modelName, text string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;Text:      text,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateImageEmbedding is a convenience method for image embeddings&#10;func (ew *EmbedWrapper) CreateImageEmbedding(modelName, imageURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;ImageURL:  imageURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateAudioEmbedding is a convenience method for audio embeddings&#10;func (ew *EmbedWrapper) CreateAudioEmbedding(modelName, audioURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;AudioURL:  audioURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;" />
              <option name="updatedContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/errors&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// EmbedWrapper provides high-level embedding generation capabilities for multiple media types&#10;// including text, images, videos, and audio content using TwelveLabs foundation models.&#10;type EmbedWrapper struct {&#10;&#9;service *services.EmbedService&#10;}&#10;&#10;// NewEmbedWrapper creates a new EmbedWrapper instance.&#10;func NewEmbedWrapper(service *services.EmbedService) *EmbedWrapper {&#10;&#9;return &amp;EmbedWrapper{service: service}&#10;}&#10;&#10;// EmbedWrapperRequest represents a comprehensive embedding request supporting all media types.&#10;// Only specify the fields relevant to your embedding type (e.g., Text for text embeddings).&#10;type EmbedWrapperRequest struct {&#10;&#9;// ModelName specifies the embedding model to use (e.g., &quot;Marengo-retrieval-2.7&quot;)&#10;&#9;ModelName string `json:&quot;model_name&quot;`&#10;&#10;&#9;// Video embedding options (use one of: VideoID, VideoFile, or VideoURL)&#10;&#9;VideoID   string `json:&quot;video_id&quot;`   // Video ID from uploaded content&#10;&#9;VideoFile string `json:&quot;video_file&quot;` // Local video file path&#10;&#9;VideoURL  string `json:&quot;video_url&quot;`  // Publicly accessible video URL&#10;&#10;&#9;// Text embedding option&#10;&#9;Text string `json:&quot;text&quot;` // Text content to embed&#10;&#10;&#9;// Audio embedding options (use one of: AudioFile or AudioURL)&#10;&#9;AudioFile string `json:&quot;audio_file&quot;` // Local audio file path&#10;&#9;AudioURL  string `json:&quot;audio_url&quot;`  // Publicly accessible audio URL&#10;&#10;&#9;// Image embedding options (use one of: ImageFile or ImageURL)&#10;&#9;ImageFile string `json:&quot;image_file&quot;` // Local image file path&#10;&#9;ImageURL  string `json:&quot;image_url&quot;`  // Publicly accessible image URL&#10;}&#10;&#10;// Create generates embeddings for any supported media type based on the request content.&#10;// This unified method automatically detects the embedding type from the provided fields.&#10;//&#10;// Supported Models:&#10;//   - &quot;Marengo-retrieval-2.7&quot;: Latest multimodal embedding model&#10;//   - &quot;Marengo-retrieval-2.6&quot;: Previous generation model&#10;//&#10;// Parameters:&#10;//   - request: EmbedWrapperRequest with ModelName and content (text, video, audio, or image)&#10;//&#10;// Returns:&#10;//   - EmbedResponse containing the generated embedding vector and metadata&#10;//   - error if embedding generation fails&#10;//&#10;// Examples:&#10;//&#10;//&#9;// Text embedding&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    Text:      &quot;A person running through a forest trail&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Video embedding from uploaded content&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    VideoID:   &quot;your_video_id&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Image embedding from URL&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    ImageURL:  &quot;https://example.com/image.jpg&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Audio embedding from local file&#10;//&#9;response, err := client.Embed.Create(&amp;wrappers.EmbedWrapperRequest{&#10;//&#9;    ModelName: &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    AudioFile: &quot;./audio/sample.mp3&quot;,&#10;//&#9;})&#10;func (ew *EmbedWrapper) Create(request *EmbedWrapperRequest) (*models.EmbedResponse, error) {&#10;&#9;// Convert to the base service request format&#10;&#9;baseRequest := &amp;models.EmbedRequest{&#10;&#9;&#9;ModelName: request.ModelName,&#10;&#9;&#9;VideoID:   request.VideoID,&#10;&#9;&#9;VideoFile: request.VideoFile,&#10;&#9;&#9;VideoURL:  request.VideoURL,&#10;&#9;&#9;Text:      request.Text,&#10;&#9;&#9;ImageURL:  request.ImageURL,&#10;&#9;&#9;ImageFile: request.ImageFile,&#10;&#9;&#9;AudioURL:  request.AudioURL,&#10;&#9;&#9;AudioFile: request.AudioFile,&#10;&#9;}&#10;&#10;&#9;// Use the existing Create method from the base service&#10;&#9;result, err := ew.service.Create(baseRequest)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Embed&quot;, &quot;embedding creation failed: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// CreateVideoEmbedding is a convenience method for video embeddings&#10;func (ew *EmbedWrapper) CreateVideoEmbedding(modelName, videoURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;VideoURL:  videoURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateTextEmbedding is a convenience method for generating text embeddings.&#10;// This method simplifies the most common embedding use case.&#10;//&#10;// Parameters:&#10;//   - modelName: The embedding model to use (e.g., &quot;Marengo-retrieval-2.7&quot;)&#10;//   - text: The text content to embed&#10;//&#10;// Returns:&#10;//   - EmbedResponse containing the text embedding vector&#10;//   - error if embedding generation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;embedding, err := client.Embed.CreateTextEmbedding(&#10;//&#9;    &quot;Marengo-retrieval-2.7&quot;,&#10;//&#9;    &quot;A beautiful sunset over the ocean&quot;,&#10;//&#9;)&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Generated %d-dimensional embedding\n&quot;, len(embedding.Embeddings))&#10;func (ew *EmbedWrapper) CreateTextEmbedding(modelName, text string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;Text:      text,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateImageEmbedding is a convenience method for image embeddings&#10;func (ew *EmbedWrapper) CreateImageEmbedding(modelName, imageURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;ImageURL:  imageURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}&#10;&#10;// CreateAudioEmbedding is a convenience method for audio embeddings&#10;func (ew *EmbedWrapper) CreateAudioEmbedding(modelName, audioURL string) (*models.EmbedResponse, error) {&#10;&#9;request := &amp;EmbedWrapperRequest{&#10;&#9;&#9;ModelName: modelName,&#10;&#9;&#9;AudioURL:  audioURL,&#10;&#9;}&#10;&#9;return ew.Create(request)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/wrappers/search.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/wrappers/search.go" />
              <option name="originalContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// SearchWrapper provides high-level multi-modal video search capabilities including&#10;// text-based semantic search, image-based visual search, and advanced query options.&#10;type SearchWrapper struct {&#10;&#9;service *services.SearchService&#10;}&#10;&#10;// NewSearchWrapper creates a new SearchWrapper instance.&#10;func NewSearchWrapper(service *services.SearchService) *SearchWrapper {&#10;&#9;return &amp;SearchWrapper{service: service}&#10;}&#10;&#10;// Query performs advanced multi-modal search with comprehensive options for filtering,&#10;// pagination, and result customization. This is the most flexible search method.&#10;//&#10;// Supports both text and media-based queries:&#10;//&#10;// Text queries:&#10;//   - Set QueryText parameter for semantic text search&#10;//&#10;// Media queries:&#10;//   - Set QueryMediaType to &quot;image&quot;, &quot;video&quot;, or &quot;audio&quot;&#10;//   - Provide either QueryMediaURL (for web URLs) or QueryMediaFile (for local files)&#10;//   - QueryMediaURL takes precedence if both are specified&#10;//&#10;// Parameters:&#10;//   - request: SearchQueryRequest containing query parameters, search options, and pagination settings&#10;//&#10;// Returns:&#10;//   - SearchResponse with paginated results and metadata&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Text-based search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{&#10;//&#9;    IndexID:       &quot;your_index_id&quot;,&#10;//&#9;    QueryText:     &quot;person running in park&quot;,&#10;//&#9;    SearchOptions: []string{&quot;visual&quot;, &quot;audio&quot;},&#10;//&#9;    PageLimit:     10,&#10;//&#9;    SortOption:    &quot;score&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Image-based search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{&#10;//&#9;    IndexID:        &quot;your_index_id&quot;,&#10;//&#9;    QueryMediaType: &quot;image&quot;,&#10;//&#9;    QueryMediaURL:  &quot;https://example.com/image.jpg&quot;,&#10;//&#9;    SearchOptions:  []string{&quot;visual&quot;},&#10;//&#9;})&#10;func (sw *SearchWrapper) Query(request *models.SearchQueryRequest) (*models.SearchResponse, error) {&#10;&#9;// Use the existing SearchQueryRequest from search service&#10;&#9;results, err := sw.service.Query(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;search query failed: %w&quot;, err)&#10;&#9;}&#10;&#9;// Return the complete response directly (no need to wrap it again)&#10;&#9;return results, nil&#10;}&#10;&#10;// Create performs a search and returns the search ID for paginated result retrieval.&#10;// This is an alias for Query() to maintain API compatibility.&#10;func (sw *SearchWrapper) Create(request *models.SearchQueryRequest) (*models.SearchResponse, error) {&#10;&#9;return sw.Query(request)&#10;}&#10;&#10;// Retrieve gets paginated search results using a page token from a previous search response.&#10;// Use this to navigate through large result sets efficiently.&#10;//&#10;// Parameters:&#10;//   - pageToken: Page token from SearchResponse.PageInfo.NextPageToken&#10;//&#10;// Returns:&#10;//   - SearchResponse with the next page of results&#10;//   - error if retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Initial search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{...})&#10;//&#10;//&#9;// Get next page if available&#10;//&#9;if response.PageInfo.NextPageToken != &quot;&quot; {&#10;//&#9;    nextPage, err := client.Search.Retrieve(response.PageInfo.NextPageToken)&#10;//&#9;}&#10;func (sw *SearchWrapper) Retrieve(pageToken string) (*models.SearchResponse, error) {&#10;&#9;return sw.service.Retrieve(pageToken)&#10;}&#10;&#10;// SearchByText is a convenience method for text-based semantic searches.&#10;// This method simplifies common text search scenarios.&#10;//&#10;// Parameters:&#10;//   - indexID: The ID of the index to search within&#10;//   - queryText: The text query describing what to search for&#10;//   - options: Search options like [&quot;visual&quot;, &quot;audio&quot;] to specify search modalities&#10;//&#10;// Returns:&#10;//   - SearchResponse with matching video segments&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;results, err := client.Search.SearchByText(&#10;//&#9;    &quot;your_index_id&quot;,&#10;//&#9;    &quot;woman talking about cooking recipes&quot;,&#10;//&#9;    []string{&quot;visual&quot;, &quot;audio&quot;},&#10;//&#9;)&#10;//&#9;for _, result := range results.Data {&#10;//&#9;    fmt.Printf(&quot;Found match in video %s at %fs\n&quot;, result.VideoID, result.Start)&#10;//&#9;}&#10;func (sw *SearchWrapper) SearchByText(indexID, queryText string, options []string) (*models.SearchResponse, error) {&#10;&#9;request := &amp;models.SearchRequest{&#10;&#9;&#9;IndexID:       indexID,&#10;&#9;&#9;QueryText:     queryText,&#10;&#9;&#9;SearchOptions: options,&#10;&#9;}&#10;&#9;return sw.Search(request)&#10;}&#10;&#10;// SearchByImage is a convenience method for image-based visual searches.&#10;// Find video segments that are visually similar to the provided image.&#10;//&#10;// Parameters:&#10;//   - indexID: The ID of the index to search within&#10;//   - imageURL: Publicly accessible URL of the image to search for&#10;//   - options: Search options, typically [&quot;visual&quot;] for image searches&#10;//&#10;// Returns:&#10;//   - SearchResponse with visually similar video segments&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;results, err := client.Search.SearchByImage(&#10;//&#9;    &quot;your_index_id&quot;,&#10;//&#9;    &quot;https://example.com/sample-image.jpg&quot;,&#10;//&#9;    []string{&quot;visual&quot;},&#10;//&#9;)&#10;//&#9;for _, result := range results.Data {&#10;//&#9;    fmt.Printf(&quot;Visual match: %s (confidence: %.2f)\n&quot;, result.VideoID, result.Score)&#10;//&#9;}&#10;func (sw *SearchWrapper) SearchByImage(indexID, imageURL string, options []string) (*models.SearchResponse, error) {&#10;&#9;request := &amp;models.SearchRequest{&#10;&#9;&#9;IndexID:        indexID,&#10;&#9;&#9;QueryMediaType: &quot;image&quot;,&#10;&#9;&#9;QueryMediaURL:  imageURL,&#10;&#9;&#9;SearchOptions:  options,&#10;&#9;}&#10;&#9;return sw.Search(request)&#10;}&#10;&#10;// Search performs a search using the legacy SearchRequest format.&#10;// For new applications, prefer using Query() or the convenience methods.&#10;//&#10;// Parameters:&#10;//   - request: SearchRequest with query parameters&#10;//&#10;// Returns:&#10;//   - SearchResponse with search results&#10;//   - error if the search fails&#10;func (sw *SearchWrapper) Search(request *models.SearchRequest) (*models.SearchResponse, error) {&#10;&#9;// Use the existing Search method from the base service&#10;&#9;results, err := sw.service.Search(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;search failed: %w&quot;, err)&#10;&#9;}&#10;&#9;return results, nil&#10;}&#10;" />
              <option name="updatedContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/errors&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// SearchWrapper provides high-level multi-modal video search capabilities including&#10;// text-based semantic search, image-based visual search, and advanced query options.&#10;type SearchWrapper struct {&#10;&#9;service *services.SearchService&#10;}&#10;&#10;// NewSearchWrapper creates a new SearchWrapper instance.&#10;func NewSearchWrapper(service *services.SearchService) *SearchWrapper {&#10;&#9;return &amp;SearchWrapper{service: service}&#10;}&#10;&#10;// Query performs advanced multi-modal search with comprehensive options for filtering,&#10;// pagination, and result customization. This is the most flexible search method.&#10;//&#10;// Supports both text and media-based queries:&#10;//&#10;// Text queries:&#10;//   - Set QueryText parameter for semantic text search&#10;//&#10;// Media queries:&#10;//   - Set QueryMediaType to &quot;image&quot;, &quot;video&quot;, or &quot;audio&quot;&#10;//   - Provide either QueryMediaURL (for web URLs) or QueryMediaFile (for local files)&#10;//   - QueryMediaURL takes precedence if both are specified&#10;//&#10;// Parameters:&#10;//   - request: SearchQueryRequest containing query parameters, search options, and pagination settings&#10;//&#10;// Returns:&#10;//   - SearchResponse with paginated results and metadata&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Text-based search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{&#10;//&#9;    IndexID:       &quot;your_index_id&quot;,&#10;//&#9;    QueryText:     &quot;person running in park&quot;,&#10;//&#9;    SearchOptions: []string{&quot;visual&quot;, &quot;audio&quot;},&#10;//&#9;    PageLimit:     10,&#10;//&#9;    SortOption:    &quot;score&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Image-based search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{&#10;//&#9;    IndexID:        &quot;your_index_id&quot;,&#10;//&#9;    QueryMediaType: &quot;image&quot;,&#10;//&#9;    QueryMediaURL:  &quot;https://example.com/image.jpg&quot;,&#10;//&#9;    SearchOptions:  []string{&quot;visual&quot;},&#10;//&#9;})&#10;func (sw *SearchWrapper) Query(request *models.SearchQueryRequest) (*models.SearchResponse, error) {&#10;&#9;// Use the existing SearchQueryRequest from search service&#10;&#9;results, err := sw.service.Query(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Search&quot;, &quot;search query failed: &quot;+err.Error())&#10;&#9;}&#10;&#9;// Return the complete response directly (no need to wrap it again)&#10;&#9;return results, nil&#10;}&#10;&#10;// Create performs a search and returns the search ID for paginated result retrieval.&#10;// This is an alias for Query() to maintain API compatibility.&#10;func (sw *SearchWrapper) Create(request *models.SearchQueryRequest) (*models.SearchResponse, error) {&#10;&#9;return sw.Query(request)&#10;}&#10;&#10;// Retrieve gets paginated search results using a page token from a previous search response.&#10;// Use this to navigate through large result sets efficiently.&#10;//&#10;// Parameters:&#10;//   - pageToken: Page token from SearchResponse.PageInfo.NextPageToken&#10;//&#10;// Returns:&#10;//   - SearchResponse with the next page of results&#10;//   - error if retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Initial search&#10;//&#9;response, err := client.Search.Query(&amp;models.SearchQueryRequest{...})&#10;//&#10;//&#9;// Get next page if available&#10;//&#9;if response.PageInfo.NextPageToken != &quot;&quot; {&#10;//&#9;    nextPage, err := client.Search.Retrieve(response.PageInfo.NextPageToken)&#10;//&#9;}&#10;func (sw *SearchWrapper) Retrieve(pageToken string) (*models.SearchResponse, error) {&#10;&#9;return sw.service.Retrieve(pageToken)&#10;}&#10;&#10;// SearchByText is a convenience method for text-based semantic searches.&#10;// This method simplifies common text search scenarios.&#10;//&#10;// Parameters:&#10;//   - indexID: The ID of the index to search within&#10;//   - queryText: The text query describing what to search for&#10;//   - options: Search options like [&quot;visual&quot;, &quot;audio&quot;] to specify search modalities&#10;//&#10;// Returns:&#10;//   - SearchResponse with matching video segments&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;results, err := client.Search.SearchByText(&#10;//&#9;    &quot;your_index_id&quot;,&#10;//&#9;    &quot;woman talking about cooking recipes&quot;,&#10;//&#9;    []string{&quot;visual&quot;, &quot;audio&quot;},&#10;//&#9;)&#10;//&#9;for _, result := range results.Data {&#10;//&#9;    fmt.Printf(&quot;Found match in video %s at %fs\n&quot;, result.VideoID, result.Start)&#10;//&#9;}&#10;func (sw *SearchWrapper) SearchByText(indexID, queryText string, options []string) (*models.SearchResponse, error) {&#10;&#9;request := &amp;models.SearchRequest{&#10;&#9;&#9;IndexID:       indexID,&#10;&#9;&#9;QueryText:     queryText,&#10;&#9;&#9;SearchOptions: options,&#10;&#9;}&#10;&#9;return sw.Search(request)&#10;}&#10;&#10;// SearchByImage is a convenience method for image-based visual searches.&#10;// Find video segments that are visually similar to the provided image.&#10;//&#10;// Parameters:&#10;//   - indexID: The ID of the index to search within&#10;//   - imageURL: Publicly accessible URL of the image to search for&#10;//   - options: Search options, typically [&quot;visual&quot;] for image searches&#10;//&#10;// Returns:&#10;//   - SearchResponse with visually similar video segments&#10;//   - error if the search fails&#10;//&#10;// Example:&#10;//&#10;//&#9;results, err := client.Search.SearchByImage(&#10;//&#9;    &quot;your_index_id&quot;,&#10;//&#9;    &quot;https://example.com/sample-image.jpg&quot;,&#10;//&#9;    []string{&quot;visual&quot;},&#10;//&#9;)&#10;//&#9;for _, result := range results.Data {&#10;//&#9;    fmt.Printf(&quot;Visual match: %s (confidence: %.2f)\n&quot;, result.VideoID, result.Score)&#10;//&#9;}&#10;func (sw *SearchWrapper) SearchByImage(indexID, imageURL string, options []string) (*models.SearchResponse, error) {&#10;&#9;request := &amp;models.SearchRequest{&#10;&#9;&#9;IndexID:        indexID,&#10;&#9;&#9;QueryMediaType: &quot;image&quot;,&#10;&#9;&#9;QueryMediaURL:  imageURL,&#10;&#9;&#9;SearchOptions:  options,&#10;&#9;}&#10;&#9;return sw.Search(request)&#10;}&#10;&#10;// Search performs a search using the legacy SearchRequest format.&#10;// For new applications, prefer using Query() or the convenience methods.&#10;//&#10;// Parameters:&#10;//   - request: SearchRequest with query parameters&#10;//&#10;// Returns:&#10;//   - SearchResponse with search results&#10;//   - error if the search fails&#10;func (sw *SearchWrapper) Search(request *models.SearchRequest) (*models.SearchResponse, error) {&#10;&#9;// Use the existing Search method from the base service&#10;&#9;results, err := sw.service.Search(request)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Search&quot;, &quot;search failed: &quot;+err.Error())&#10;&#9;}&#10;&#9;return results, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/wrappers/tasks.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/wrappers/tasks.go" />
              <option name="originalContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// TasksWrapper provides enhanced task management capabilities for video upload and processing,&#10;// including bulk operations, progress tracking, and completion waiting with callbacks.&#10;type TasksWrapper struct {&#10;&#9;service *services.TasksService&#10;}&#10;&#10;// NewTasksWrapper creates a new TasksWrapper instance.&#10;func NewTasksWrapper(service *services.TasksService) *TasksWrapper {&#10;&#9;return &amp;TasksWrapper{service: service}&#10;}&#10;&#10;// Create creates a single video indexing task for uploading and processing a video.&#10;// Supports both local files and publicly accessible URLs.&#10;//&#10;// Parameters:&#10;//   - request: TasksCreateRequest with IndexID and either VideoFile or VideoURL&#10;//&#10;// Returns:&#10;//   - Task containing the task ID and initial status&#10;//   - error if task creation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Upload local file&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID:   &quot;your_index_id&quot;,&#10;//&#9;    VideoFile: &quot;./videos/sample.mp4&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Upload from URL&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID:  &quot;your_index_id&quot;,&#10;//&#9;    VideoURL: &quot;https://example.com/video.mp4&quot;,&#10;//&#9;})&#10;func (tw *TasksWrapper) Create(request *models.TasksCreateRequest) (*models.Task, error) {&#10;&#9;return tw.service.Create(request)&#10;}&#10;&#10;// List retrieves tasks with optional filtering by status, index ID, or other criteria.&#10;//&#10;// Parameters:&#10;//   - filters: Map of filter criteria (e.g., {&quot;status&quot;: &quot;completed&quot;, &quot;index_id&quot;: &quot;your_index&quot;})&#10;//&#10;// Returns:&#10;//   - Array of Task objects matching the filter criteria&#10;//   - error if retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Get all completed tasks&#10;//&#9;tasks, err := client.Tasks.List(map[string]string{&#10;//&#9;    &quot;status&quot;: &quot;completed&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Get tasks for specific index&#10;//&#9;tasks, err := client.Tasks.List(map[string]string{&#10;//&#9;    &quot;index_id&quot;: &quot;your_index_id&quot;,&#10;//&#9;})&#10;func (tw *TasksWrapper) List(filters map[string]string) ([]models.Task, error) {&#10;&#9;return tw.service.List(filters)&#10;}&#10;&#10;// Retrieve gets detailed information about a specific task by its ID.&#10;//&#10;// Parameters:&#10;//   - taskID: The unique identifier of the task&#10;//&#10;// Returns:&#10;//   - Task object with current status and metadata&#10;//   - error if task not found or retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;task, err := client.Tasks.Retrieve(&quot;task_id_here&quot;)&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Task status: %s\n&quot;, task.Status)&#10;func (tw *TasksWrapper) Retrieve(taskID string) (*models.Task, error) {&#10;&#9;return tw.service.Retrieve(taskID)&#10;}&#10;&#10;// CreateBulkRequest represents a request for creating multiple video indexing tasks simultaneously.&#10;// This enables efficient batch processing of multiple videos.&#10;type CreateBulkRequest struct {&#10;&#9;// IndexID is the target index for all videos&#10;&#9;IndexID string `json:&quot;index_id&quot;`&#10;&#9;// VideoFiles contains paths to local video files (optional)&#10;&#9;VideoFiles []string `json:&quot;video_files,omitempty&quot;`&#10;&#9;// VideoURLs contains publicly accessible video URLs (optional)&#10;&#9;VideoURLs []string `json:&quot;video_urls,omitempty&quot;`&#10;&#9;// EnableVideoStream enables video streaming for processed content (optional)&#10;&#9;EnableVideoStream bool `json:&quot;enable_video_stream,omitempty&quot;`&#10;}&#10;&#10;// CreateBulk creates multiple video indexing tasks for batch processing of videos.&#10;// This method efficiently handles bulk video uploads and processing.&#10;//&#10;// Upload options:&#10;//   - Local files: Use VideoFiles to provide an array of file paths&#10;//   - Publicly accessible URLs: Use VideoURLs to provide an array of URLs&#10;//   - Mixed sources: Can combine both local files and URLs in a single request&#10;//&#10;// Parameters:&#10;//   - request: CreateBulkRequest with IndexID and video sources&#10;//&#10;// Returns:&#10;//   - Array of Task objects, one for each video&#10;//   - error if bulk task creation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;tasks, err := client.Tasks.CreateBulk(&amp;wrappers.CreateBulkRequest{&#10;//&#9;    IndexID: &quot;your_index_id&quot;,&#10;//&#9;    VideoFiles: []string{&#10;//&#9;        &quot;./videos/video1.mp4&quot;,&#10;//&#9;        &quot;./videos/video2.mp4&quot;,&#10;//&#9;    },&#10;//&#9;    VideoURLs: []string{&#10;//&#9;        &quot;https://example.com/video3.mp4&quot;,&#10;//&#9;        &quot;https://example.com/video4.mp4&quot;,&#10;//&#9;    },&#10;//&#9;    EnableVideoStream: true,&#10;//&#9;})&#10;//&#9;fmt.Printf(&quot;Created %d tasks\n&quot;, len(tasks))&#10;func (tw *TasksWrapper) CreateBulk(request *CreateBulkRequest) ([]models.Task, error) {&#10;&#9;if len(request.VideoFiles) == 0 &amp;&amp; len(request.VideoURLs) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;either VideoFiles or VideoURLs must be provided&quot;)&#10;&#9;}&#10;&#10;&#9;var tasks []models.Task&#10;&#10;&#9;// Process video files&#10;&#9;if len(request.VideoFiles) &gt; 0 {&#10;&#9;&#9;for _, videoFile := range request.VideoFiles {&#10;&#9;&#9;&#9;taskRequest := &amp;models.TasksCreateRequest{&#10;&#9;&#9;&#9;&#9;IndexID:           request.IndexID,&#10;&#9;&#9;&#9;&#9;VideoFile:         videoFile,&#10;&#9;&#9;&#9;&#9;EnableVideoStream: request.EnableVideoStream,&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;task, err := tw.service.Create(taskRequest)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Error processing file %s: %v\n&quot;, videoFile, err)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;tasks = append(tasks, *task)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Process video URLs&#10;&#9;if len(request.VideoURLs) &gt; 0 {&#10;&#9;&#9;for _, videoURL := range request.VideoURLs {&#10;&#9;&#9;&#9;taskRequest := &amp;models.TasksCreateRequest{&#10;&#9;&#9;&#9;&#9;IndexID:           request.IndexID,&#10;&#9;&#9;&#9;&#9;VideoURL:          videoURL,&#10;&#9;&#9;&#9;&#9;EnableVideoStream: request.EnableVideoStream,&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;task, err := tw.service.Create(taskRequest)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Error processing URL %s: %v\n&quot;, videoURL, err)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;tasks = append(tasks, *task)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return tasks, nil&#10;}&#10;&#10;// WaitForDoneOptions represents options for the WaitForDone method&#10;type WaitForDoneOptions struct {&#10;&#9;SleepInterval time.Duration&#10;&#9;Callback      func(*models.Task) error&#10;}&#10;&#10;// WaitForDone waits for a task to complete by periodically checking its status.&#10;//&#10;// Parameters:&#10;//   - taskID: The unique identifier of the task to wait for&#10;//   - options: Options for the wait operation including sleep interval and callback&#10;//&#10;// Returns: The completed task response&#10;//&#10;// Example:&#10;//&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID: &quot;index_id&quot;,&#10;//&#9;    VideoURL: &quot;https://example.com/video.mp4&quot;,&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#10;//&#9;completedTask, err := client.Tasks.WaitForDone(task.ID, &amp;WaitForDoneOptions{&#10;//&#9;    SleepInterval: 10 * time.Second,&#10;//&#9;    Callback: func(task *models.Task) error {&#10;//&#9;        fmt.Printf(&quot;Current status: %s\n&quot;, task.Status)&#10;//&#9;        return nil&#10;//&#9;    },&#10;//&#9;})&#10;func (tw *TasksWrapper) WaitForDone(taskID string, options *WaitForDoneOptions) (*models.Task, error) {&#10;&#9;if options == nil {&#10;&#9;&#9;options = &amp;WaitForDoneOptions{}&#10;&#9;}&#10;&#10;&#9;sleepInterval := options.SleepInterval&#10;&#9;if sleepInterval &lt;= 0 {&#10;&#9;&#9;sleepInterval = 5 * time.Second&#10;&#9;}&#10;&#10;&#9;callback := options.Callback&#10;&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to retrieve initial task: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Continue checking until it's done&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;time.Sleep(sleepInterval)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;Retrieving task failed: %v. Retrying...\n&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;if err := callback(task); err != nil {&#10;&#9;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;callback error: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return task, nil&#10;}&#10;&#10;// WaitForCompletion waits for a task to complete, calling the optional callback function&#10;// with status updates. This method polls the task status at regular intervals.&#10;//&#10;// Parameters:&#10;//   - taskID: The task ID to monitor&#10;//   - callback: Optional function called with each status update (can be nil)&#10;//&#10;// Returns:&#10;//   - error if the task fails or polling encounters an error&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Tasks.WaitForCompletion(&quot;task_id&quot;, func(status string) {&#10;//&#9;    fmt.Printf(&quot;Task status: %s\n&quot;, status)&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Printf(&quot;Task failed: %v&quot;, err)&#10;//&#9;} else {&#10;//&#9;    fmt.Println(&quot;Task completed successfully!&quot;)&#10;//&#9;}&#10;func (tw *TasksWrapper) WaitForCompletion(taskID string, callback func(string)) error {&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to retrieve initial task: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Continue checking until it's done&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;retrieving task failed: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;callback(task.Status)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// WaitForCompletionWithTimeout waits for task completion with a specified timeout.&#10;// This prevents indefinite waiting for stuck or very long-running tasks.&#10;//&#10;// Parameters:&#10;//   - taskID: The task ID to monitor&#10;//   - timeout: Maximum time to wait for completion&#10;//   - callback: Optional function called with status updates&#10;//&#10;// Returns:&#10;//   - error if timeout exceeded, task fails, or polling encounters an error&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Tasks.WaitForCompletionWithTimeout(&#10;//&#9;    &quot;task_id&quot;,&#10;//&#9;    10*time.Minute,&#10;//&#9;    func(status string) {&#10;//&#9;        fmt.Printf(&quot;Status: %s\n&quot;, status)&#10;//&#9;    },&#10;//&#9;)&#10;func (tw *TasksWrapper) WaitForCompletionWithTimeout(taskID string, timeout time.Duration, callback func(string)) error {&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to retrieve initial task: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Set a deadline for completion&#10;&#9;deadline := time.Now().Add(timeout)&#10;&#10;&#9;// Continue checking until it's done or timeout&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;if time.Now().After(deadline) {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;timeout exceeded while waiting for task completion&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;retrieving task failed: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;callback(task.Status)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package wrappers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/errors&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/models&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/services&quot;&#10;)&#10;&#10;// TasksWrapper provides enhanced task management capabilities for video upload and processing,&#10;// including bulk operations, progress tracking, and completion waiting with callbacks.&#10;type TasksWrapper struct {&#10;&#9;service *services.TasksService&#10;}&#10;&#10;// NewTasksWrapper creates a new TasksWrapper instance.&#10;func NewTasksWrapper(service *services.TasksService) *TasksWrapper {&#10;&#9;return &amp;TasksWrapper{service: service}&#10;}&#10;&#10;// Create creates a single video indexing task for uploading and processing a video.&#10;// Supports both local files and publicly accessible URLs.&#10;//&#10;// Parameters:&#10;//   - request: TasksCreateRequest with IndexID and either VideoFile or VideoURL&#10;//&#10;// Returns:&#10;//   - Task containing the task ID and initial status&#10;//   - error if task creation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Upload local file&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID:   &quot;your_index_id&quot;,&#10;//&#9;    VideoFile: &quot;./videos/sample.mp4&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Upload from URL&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID:  &quot;your_index_id&quot;,&#10;//&#9;    VideoURL: &quot;https://example.com/video.mp4&quot;,&#10;//&#9;})&#10;func (tw *TasksWrapper) Create(request *models.TasksCreateRequest) (*models.Task, error) {&#10;&#9;return tw.service.Create(request)&#10;}&#10;&#10;// List retrieves tasks with optional filtering by status, index ID, or other criteria.&#10;//&#10;// Parameters:&#10;//   - filters: Map of filter criteria (e.g., {&quot;status&quot;: &quot;completed&quot;, &quot;index_id&quot;: &quot;your_index&quot;})&#10;//&#10;// Returns:&#10;//   - Array of Task objects matching the filter criteria&#10;//   - error if retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;// Get all completed tasks&#10;//&#9;tasks, err := client.Tasks.List(map[string]string{&#10;//&#9;    &quot;status&quot;: &quot;completed&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Get tasks for specific index&#10;//&#9;tasks, err := client.Tasks.List(map[string]string{&#10;//&#9;    &quot;index_id&quot;: &quot;your_index_id&quot;,&#10;//&#9;})&#10;func (tw *TasksWrapper) List(filters map[string]string) ([]models.Task, error) {&#10;&#9;return tw.service.List(filters)&#10;}&#10;&#10;// Retrieve gets detailed information about a specific task by its ID.&#10;//&#10;// Parameters:&#10;//   - taskID: The unique identifier of the task&#10;//&#10;// Returns:&#10;//   - Task object with current status and metadata&#10;//   - error if task not found or retrieval fails&#10;//&#10;// Example:&#10;//&#10;//&#9;task, err := client.Tasks.Retrieve(&quot;task_id_here&quot;)&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#9;fmt.Printf(&quot;Task status: %s\n&quot;, task.Status)&#10;func (tw *TasksWrapper) Retrieve(taskID string) (*models.Task, error) {&#10;&#9;return tw.service.Retrieve(taskID)&#10;}&#10;&#10;// CreateBulkRequest represents a request for creating multiple video indexing tasks simultaneously.&#10;// This enables efficient batch processing of multiple videos.&#10;type CreateBulkRequest struct {&#10;&#9;// IndexID is the target index for all videos&#10;&#9;IndexID string `json:&quot;index_id&quot;`&#10;&#9;// VideoFiles contains paths to local video files (optional)&#10;&#9;VideoFiles []string `json:&quot;video_files,omitempty&quot;`&#10;&#9;// VideoURLs contains publicly accessible video URLs (optional)&#10;&#9;VideoURLs []string `json:&quot;video_urls,omitempty&quot;`&#10;&#9;// EnableVideoStream enables video streaming for processed content (optional)&#10;&#9;EnableVideoStream bool `json:&quot;enable_video_stream,omitempty&quot;`&#10;}&#10;&#10;// CreateBulk creates multiple video indexing tasks for batch processing of videos.&#10;// This method efficiently handles bulk video uploads and processing.&#10;//&#10;// Upload options:&#10;//   - Local files: Use VideoFiles to provide an array of file paths&#10;//   - Publicly accessible URLs: Use VideoURLs to provide an array of URLs&#10;//   - Mixed sources: Can combine both local files and URLs in a single request&#10;//&#10;// Parameters:&#10;//   - request: CreateBulkRequest with IndexID and video sources&#10;//&#10;// Returns:&#10;//   - Array of Task objects, one for each video&#10;//   - error if bulk task creation fails&#10;//&#10;// Example:&#10;//&#10;//&#9;tasks, err := client.Tasks.CreateBulk(&amp;wrappers.CreateBulkRequest{&#10;//&#9;    IndexID: &quot;your_index_id&quot;,&#10;//&#9;    VideoFiles: []string{&#10;//&#9;        &quot;./videos/video1.mp4&quot;,&#10;//&#9;        &quot;./videos/video2.mp4&quot;,&#10;//&#9;    },&#10;//&#9;    VideoURLs: []string{&#10;//&#9;        &quot;https://example.com/video3.mp4&quot;,&#10;//&#9;        &quot;https://example.com/video4.mp4&quot;,&#10;//&#9;    },&#10;//&#9;    EnableVideoStream: true,&#10;//&#9;})&#10;//&#9;fmt.Printf(&quot;Created %d tasks\n&quot;, len(tasks))&#10;func (tw *TasksWrapper) CreateBulk(request *CreateBulkRequest) ([]models.Task, error) {&#10;&#9;if len(request.VideoFiles) == 0 &amp;&amp; len(request.VideoURLs) == 0 {&#10;&#9;&#9;return nil, errors.NewValidationError(&quot;either VideoFiles or VideoURLs must be provided&quot;)&#10;&#9;}&#10;&#10;&#9;var tasks []models.Task&#10;&#10;&#9;// Process video files&#10;&#9;if len(request.VideoFiles) &gt; 0 {&#10;&#9;&#9;for _, videoFile := range request.VideoFiles {&#10;&#9;&#9;&#9;taskRequest := &amp;models.TasksCreateRequest{&#10;&#9;&#9;&#9;&#9;IndexID:           request.IndexID,&#10;&#9;&#9;&#9;&#9;VideoFile:         videoFile,&#10;&#9;&#9;&#9;&#9;EnableVideoStream: request.EnableVideoStream,&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;task, err := tw.service.Create(taskRequest)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Error processing file %s: %v\n&quot;, videoFile, err)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;tasks = append(tasks, *task)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Process video URLs&#10;&#9;if len(request.VideoURLs) &gt; 0 {&#10;&#9;&#9;for _, videoURL := range request.VideoURLs {&#10;&#9;&#9;&#9;taskRequest := &amp;models.TasksCreateRequest{&#10;&#9;&#9;&#9;&#9;IndexID:           request.IndexID,&#10;&#9;&#9;&#9;&#9;VideoURL:          videoURL,&#10;&#9;&#9;&#9;&#9;EnableVideoStream: request.EnableVideoStream,&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;task, err := tw.service.Create(taskRequest)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Error processing URL %s: %v\n&quot;, videoURL, err)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;tasks = append(tasks, *task)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return tasks, nil&#10;}&#10;&#10;// WaitForDoneOptions represents options for the WaitForDone method&#10;type WaitForDoneOptions struct {&#10;&#9;SleepInterval time.Duration&#10;&#9;Callback      func(*models.Task) error&#10;}&#10;&#10;// WaitForDone waits for a task to complete by periodically checking its status.&#10;//&#10;// Parameters:&#10;//   - taskID: The unique identifier of the task to wait for&#10;//   - options: Options for the wait operation including sleep interval and callback&#10;//&#10;// Returns: The completed task response&#10;//&#10;// Example:&#10;//&#10;//&#9;task, err := client.Tasks.Create(&amp;models.TasksCreateRequest{&#10;//&#9;    IndexID: &quot;index_id&quot;,&#10;//&#9;    VideoURL: &quot;https://example.com/video.mp4&quot;,&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#10;//&#9;completedTask, err := client.Tasks.WaitForDone(task.ID, &amp;WaitForDoneOptions{&#10;//&#9;    SleepInterval: 10 * time.Second,&#10;//&#9;    Callback: func(task *models.Task) error {&#10;//&#9;        fmt.Printf(&quot;Current status: %s\n&quot;, task.Status)&#10;//&#9;        return nil&#10;//&#9;    },&#10;//&#9;})&#10;func (tw *TasksWrapper) WaitForDone(taskID string, options *WaitForDoneOptions) (*models.Task, error) {&#10;&#9;if options == nil {&#10;&#9;&#9;options = &amp;WaitForDoneOptions{}&#10;&#9;}&#10;&#10;&#9;sleepInterval := options.SleepInterval&#10;&#9;if sleepInterval &lt;= 0 {&#10;&#9;&#9;sleepInterval = 5 * time.Second&#10;&#9;}&#10;&#10;&#9;callback := options.Callback&#10;&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, errors.NewServiceError(&quot;Tasks&quot;, &quot;failed to retrieve initial task: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Continue checking until it's done&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;time.Sleep(sleepInterval)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;Retrieving task failed: %v. Retrying...\n&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;if err := callback(task); err != nil {&#10;&#9;&#9;&#9;&#9;return nil, errors.NewServiceError(&quot;Tasks&quot;, &quot;callback error: &quot;+err.Error())&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return task, nil&#10;}&#10;&#10;// WaitForCompletion waits for a task to complete, calling the optional callback function&#10;// with status updates. This method polls the task status at regular intervals.&#10;//&#10;// Parameters:&#10;//   - taskID: The task ID to monitor&#10;//   - callback: Optional function called with each status update (can be nil)&#10;//&#10;// Returns:&#10;//   - error if the task fails or polling encounters an error&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Tasks.WaitForCompletion(&quot;task_id&quot;, func(status string) {&#10;//&#9;    fmt.Printf(&quot;Task status: %s\n&quot;, status)&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Printf(&quot;Task failed: %v&quot;, err)&#10;//&#9;} else {&#10;//&#9;    fmt.Println(&quot;Task completed successfully!&quot;)&#10;//&#9;}&#10;func (tw *TasksWrapper) WaitForCompletion(taskID string, callback func(string)) error {&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return errors.NewServiceError(&quot;Tasks&quot;, &quot;failed to retrieve initial task: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Continue checking until it's done&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return errors.NewServiceError(&quot;Tasks&quot;, &quot;retrieving task failed: &quot;+err.Error())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;callback(task.Status)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// WaitForCompletionWithTimeout waits for task completion with a specified timeout.&#10;// This prevents indefinite waiting for stuck or very long-running tasks.&#10;//&#10;// Parameters:&#10;//   - taskID: The task ID to monitor&#10;//   - timeout: Maximum time to wait for completion&#10;//   - callback: Optional function called with status updates&#10;//&#10;// Returns:&#10;//   - error if timeout exceeded, task fails, or polling encounters an error&#10;//&#10;// Example:&#10;//&#10;//&#9;err := client.Tasks.WaitForCompletionWithTimeout(&#10;//&#9;    &quot;task_id&quot;,&#10;//&#9;    10*time.Minute,&#10;//&#9;    func(status string) {&#10;//&#9;        fmt.Printf(&quot;Status: %s\n&quot;, status)&#10;//&#9;    },&#10;//&#9;)&#10;func (tw *TasksWrapper) WaitForCompletionWithTimeout(taskID string, timeout time.Duration, callback func(string)) error {&#10;&#9;// Get initial task&#10;&#9;task, err := tw.service.Retrieve(taskID)&#10;&#9;if err != nil {&#10;&#9;&#9;return errors.NewServiceError(&quot;Tasks&quot;, &quot;failed to retrieve initial task: &quot;+err.Error())&#10;&#9;}&#10;&#10;&#9;// Define done statuses&#10;&#9;doneStatuses := map[string]bool{&#10;&#9;&#9;&quot;ready&quot;:  true,&#10;&#9;&#9;&quot;failed&quot;: true,&#10;&#9;}&#10;&#10;&#9;// Set a deadline for completion&#10;&#9;deadline := time.Now().Add(timeout)&#10;&#10;&#9;// Continue checking until it's done or timeout&#10;&#9;for !doneStatuses[task.Status] {&#10;&#9;&#9;if time.Now().After(deadline) {&#10;&#9;&#9;&#9;return errors.NewTimeoutError(&quot;timeout exceeded while waiting for task completion&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;&#9;task, err = tw.service.Retrieve(taskID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return errors.NewServiceError(&quot;Tasks&quot;, &quot;retrieving task failed: &quot;+err.Error())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Call callback if provided&#10;&#9;&#9;if callback != nil {&#10;&#9;&#9;&#9;callback(task.Status)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/twelvelabs.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/twelvelabs.go" />
              <option name="originalContent" value="// Package twelvelabs provides a comprehensive Go SDK for the TwelveLabs API,&#10;// enabling advanced video understanding, analysis, search, and embedding capabilities.&#10;//&#10;// The SDK supports:&#10;// - Video analysis with custom prompts and streaming responses&#10;// - Video summarization, chapter generation, and gist creation&#10;// - Multi-modal search (text, image, video, audio)&#10;// - Embedding generation for various media types&#10;// - Asynchronous video upload and processing&#10;// - Index and video management&#10;//&#10;// Example usage:&#10;//&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(&amp;twelvelabs.Options{&#10;//&#9;    APIKey: &quot;your-api-key&quot;,&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#10;//&#9;// Analyze a video&#10;//&#9;response, err := client.Analyze.Analyze(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID: &quot;video-id&quot;,&#10;//&#9;    Prompt:  &quot;What objects are visible in this video?&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Search for content&#10;//&#9;results, err := client.Search.SearchByText(&quot;index-id&quot;, &quot;person running&quot;, []string{&quot;visual&quot;})&#10;//&#10;//&#9;// Generate embeddings&#10;//&#9;embedding, err := client.Embed.CreateTextEmbedding(&quot;Marengo-retrieval-2.7&quot;, &quot;sample text&quot;)&#10;package twelvelabs&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/client&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/wrappers&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// TwelveLabs is the main client that provides access to all TwelveLabs API services.&#10;// It includes five core service areas:&#10;//   - Analyze: Video analysis, summarization, and gist generation&#10;//   - Search: Multi-modal video search capabilities&#10;//   - Embed: Embedding generation for text, images, videos, and audio&#10;//   - Tasks: Asynchronous video processing and upload management&#10;//   - Indexes: Video index creation and management&#10;type TwelveLabs struct {&#10;&#9;client  *client.Client&#10;&#9;options *Options&#10;&#9;Tasks   *wrappers.TasksWrapper&#10;&#9;Indexes *wrappers.IndexesWrapper&#10;&#9;Search  *wrappers.SearchWrapper&#10;&#9;Embed   *wrappers.EmbedWrapper&#10;&#9;Analyze *wrappers.AnalyzeWrapper&#10;}&#10;&#10;// Options represents configuration options for the TwelveLabs client.&#10;// All fields are optional and will use sensible defaults or environment variables.&#10;type Options struct {&#10;&#9;// APIKey is your TwelveLabs API key. If empty, uses TWELVE_LABS_API_KEY environment variable.&#10;&#9;APIKey string&#10;&#9;// BaseURL is the API base URL. If empty, uses TWELVELABS_BASE_URL environment variable or default.&#10;&#9;BaseURL string&#10;&#9;// Timeout is the HTTP client timeout. If zero, uses a default timeout.&#10;&#9;Timeout time.Duration&#10;}&#10;&#10;// NewTwelveLabs creates a new TwelveLabs client with the provided options.&#10;// If options is nil, default configuration will be used.&#10;//&#10;// The client will automatically use environment variables:&#10;//   - TWELVE_LABS_API_KEY: API key (required if not provided in options)&#10;//   - TWELVELABS_BASE_URL: Custom base URL (optional)&#10;//&#10;// Example:&#10;//&#10;//&#9;// Using environment variable&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(nil)&#10;//&#10;//&#9;// Using explicit options&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(&amp;twelvelabs.Options{&#10;//&#9;    APIKey: &quot;your-api-key&quot;,&#10;//&#9;    BaseURL: &quot;https://api.twelvelabs.io&quot;,&#10;//&#9;    Timeout: 30 * time.Second,&#10;//&#9;})&#10;func NewTwelveLabs(options *Options) (*TwelveLabs, error) {&#10;&#9;if options == nil {&#10;&#9;&#9;options = &amp;Options{}&#10;&#9;}&#10;&#10;&#9;// Use environment variable if API key is not provided&#10;&#9;apiKey := options.APIKey&#10;&#9;if apiKey == &quot;&quot; {&#10;&#9;&#9;apiKey = os.Getenv(&quot;TWELVE_LABS_API_KEY&quot;)&#10;&#9;}&#10;&#10;&#9;if apiKey == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;provide APIKey to initialize a client or set the TWELVE_LABS_API_KEY environment variable. You can see the API Key in the Dashboard page: https://dashboard.playground.io&quot;)&#10;&#9;}&#10;&#10;&#9;// Set default base URL if not provided&#10;&#9;baseURL := options.BaseURL&#10;&#9;if baseURL == &quot;&quot; {&#10;&#9;&#9;baseURL = os.Getenv(&quot;TWELVELABS_BASE_URL&quot;)&#10;&#9;&#9;if baseURL == &quot;&quot; {&#10;&#9;&#9;&#9;baseURL = client.DefaultBaseURL&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Set default timeout if not provided&#10;&#9;timeout := options.Timeout&#10;&#9;if timeout == 0 {&#10;&#9;&#9;timeout = client.DefaultTimeout&#10;&#9;}&#10;&#10;&#9;clientOptions := &amp;client.Options{&#10;&#9;&#9;APIKey:  apiKey,&#10;&#9;&#9;BaseURL: baseURL,&#10;&#9;&#9;Timeout: timeout,&#10;&#9;}&#10;&#10;&#9;apiClient := client.NewClient(clientOptions)&#10;&#10;&#9;return &amp;TwelveLabs{&#10;&#9;&#9;client:  apiClient,&#10;&#9;&#9;options: options,&#10;&#9;&#9;Tasks:   wrappers.NewTasksWrapper(apiClient.Tasks),&#10;&#9;&#9;Indexes: wrappers.NewIndexesWrapper(apiClient.Indexes),&#10;&#9;&#9;Search:  wrappers.NewSearchWrapper(apiClient.Search),&#10;&#9;&#9;Embed:   wrappers.NewEmbedWrapper(apiClient.Embed),&#10;&#9;&#9;Analyze: wrappers.NewAnalyzeWrapper(apiClient.Analyze),&#10;&#9;}, nil&#10;}&#10;&#10;// GetCustomAuthorizationHeaders returns the authorization headers used for API requests.&#10;// This method is primarily for internal use but can be helpful for debugging.&#10;func (t *TwelveLabs) GetCustomAuthorizationHeaders() map[string]string {&#10;&#9;return map[string]string{&#10;&#9;&#9;&quot;x-api-key&quot;: t.options.APIKey,&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="// Package twelvelabs provides a comprehensive Go SDK for the TwelveLabs API,&#10;// enabling advanced video understanding, analysis, search, and embedding capabilities.&#10;//&#10;// The SDK supports:&#10;// - Video analysis with custom prompts and streaming responses&#10;// - Video summarization, chapter generation, and gist creation&#10;// - Multi-modal search (text, image, video, audio)&#10;// - Embedding generation for various media types&#10;// - Asynchronous video upload and processing&#10;// - Index and video management&#10;//&#10;// Example usage:&#10;//&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(&amp;twelvelabs.Options{&#10;//&#9;    APIKey: &quot;your-api-key&quot;,&#10;//&#9;})&#10;//&#9;if err != nil {&#10;//&#9;    log.Fatal(err)&#10;//&#9;}&#10;//&#10;//&#9;// Analyze a video&#10;//&#9;response, err := client.Analyze.Analyze(&amp;models.AnalyzeRequest{&#10;//&#9;    VideoID: &quot;video-id&quot;,&#10;//&#9;    Prompt:  &quot;What objects are visible in this video?&quot;,&#10;//&#9;})&#10;//&#10;//&#9;// Search for content&#10;//&#9;results, err := client.Search.SearchByText(&quot;index-id&quot;, &quot;person running&quot;, []string{&quot;visual&quot;})&#10;//&#10;//&#9;// Generate embeddings&#10;//&#9;embedding, err := client.Embed.CreateTextEmbedding(&quot;Marengo-retrieval-2.7&quot;, &quot;sample text&quot;)&#10;package twelvelabs&#10;&#10;import (&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/client&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/errors&quot;&#10;&#9;&quot;github.com/favourthemaster/twelvelabs-go-sdk/pkg/wrappers&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// TwelveLabs is the main client that provides access to all TwelveLabs API services.&#10;// It includes five core service areas:&#10;//   - Analyze: Video analysis, summarization, and gist generation&#10;//   - Search: Multi-modal video search capabilities&#10;//   - Embed: Embedding generation for text, images, videos, and audio&#10;//   - Tasks: Asynchronous video processing and upload management&#10;//   - Indexes: Video index creation and management&#10;type TwelveLabs struct {&#10;&#9;client  *client.Client&#10;&#9;options *Options&#10;&#9;Tasks   *wrappers.TasksWrapper&#10;&#9;Indexes *wrappers.IndexesWrapper&#10;&#9;Search  *wrappers.SearchWrapper&#10;&#9;Embed   *wrappers.EmbedWrapper&#10;&#9;Analyze *wrappers.AnalyzeWrapper&#10;}&#10;&#10;// Options represents configuration options for the TwelveLabs client.&#10;// All fields are optional and will use sensible defaults or environment variables.&#10;type Options struct {&#10;&#9;// APIKey is your TwelveLabs API key. If empty, uses TWELVE_LABS_API_KEY environment variable.&#10;&#9;APIKey string&#10;&#9;// BaseURL is the API base URL. If empty, uses TWELVELABS_BASE_URL environment variable or default.&#10;&#9;BaseURL string&#10;&#9;// Timeout is the HTTP client timeout. If zero, uses a default timeout.&#10;&#9;Timeout time.Duration&#10;}&#10;&#10;// NewTwelveLabs creates a new TwelveLabs client with the provided options.&#10;// If options is nil, default configuration will be used.&#10;//&#10;// The client will automatically use environment variables:&#10;//   - TWELVE_LABS_API_KEY: API key (required if not provided in options)&#10;//   - TWELVELABS_BASE_URL: Custom base URL (optional)&#10;//&#10;// Example:&#10;//&#10;//&#9;// Using environment variable&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(nil)&#10;//&#10;//&#9;// Using explicit options&#10;//&#9;client, err := twelvelabs.NewTwelveLabs(&amp;twelvelabs.Options{&#10;//&#9;    APIKey: &quot;your-api-key&quot;,&#10;//&#9;    BaseURL: &quot;https://api.twelvelabs.io&quot;,&#10;//&#9;    Timeout: 30 * time.Second,&#10;//&#9;})&#10;func NewTwelveLabs(options *Options) (*TwelveLabs, error) {&#10;&#9;if options == nil {&#10;&#9;&#9;options = &amp;Options{}&#10;&#9;}&#10;&#10;&#9;// Use environment variable if API key is not provided&#10;&#9;apiKey := options.APIKey&#10;&#9;if apiKey == &quot;&quot; {&#10;&#9;&#9;apiKey = os.Getenv(&quot;TWELVE_LABS_API_KEY&quot;)&#10;&#9;}&#10;&#10;&#9;if apiKey == &quot;&quot; {&#10;&#9;&#9;return nil, errors.NewUnauthorizedError(&quot;provide APIKey to initialize a client or set the TWELVE_LABS_API_KEY environment variable. You can see the API Key in the Dashboard page: https://dashboard.playground.io&quot;)&#10;&#9;}&#10;&#10;&#9;// Set default base URL if not provided&#10;&#9;baseURL := options.BaseURL&#10;&#9;if baseURL == &quot;&quot; {&#10;&#9;&#9;baseURL = os.Getenv(&quot;TWELVELABS_BASE_URL&quot;)&#10;&#9;&#9;if baseURL == &quot;&quot; {&#10;&#9;&#9;&#9;baseURL = client.DefaultBaseURL&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Set default timeout if not provided&#10;&#9;timeout := options.Timeout&#10;&#9;if timeout == 0 {&#10;&#9;&#9;timeout = client.DefaultTimeout&#10;&#9;}&#10;&#10;&#9;clientOptions := &amp;client.Options{&#10;&#9;&#9;APIKey:  apiKey,&#10;&#9;&#9;BaseURL: baseURL,&#10;&#9;&#9;Timeout: timeout,&#10;&#9;}&#10;&#10;&#9;apiClient := client.NewClient(clientOptions)&#10;&#10;&#9;return &amp;TwelveLabs{&#10;&#9;&#9;client:  apiClient,&#10;&#9;&#9;options: options,&#10;&#9;&#9;Tasks:   wrappers.NewTasksWrapper(apiClient.Tasks),&#10;&#9;&#9;Indexes: wrappers.NewIndexesWrapper(apiClient.Indexes),&#10;&#9;&#9;Search:  wrappers.NewSearchWrapper(apiClient.Search),&#10;&#9;&#9;Embed:   wrappers.NewEmbedWrapper(apiClient.Embed),&#10;&#9;&#9;Analyze: wrappers.NewAnalyzeWrapper(apiClient.Analyze),&#10;&#9;}, nil&#10;}&#10;&#10;// GetCustomAuthorizationHeaders returns the authorization headers used for API requests.&#10;// This method is primarily for internal use but can be helpful for debugging.&#10;func (t *TwelveLabs) GetCustomAuthorizationHeaders() map[string]string {&#10;&#9;return map[string]string{&#10;&#9;&#9;&quot;x-api-key&quot;: t.options.APIKey,&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>